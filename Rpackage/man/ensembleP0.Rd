% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ensembleP0.R
\name{ensembleP0}
\alias{ensembleP0}
\title{Estimate \eqn{P_0}}
\usage{
ensembleP0(
  mdr,
  cdr,
  windowSize,
  slidingSpeed,
  sampleSize,
  NsampleSets = 100L,
  targetMDRs = c(1:10000, seq(10000L + 10L, 100000L - 10L, by = 10L))/1e+05,
  interpolationMethod = "linear",
  linearIntpoThenCpp = TRUE,
  randomSeed = 42L,
  maxCore = parallel::detectCores(),
  tempDir = "../tempFiles/CharlieTempMP/C",
  verbose = TRUE
)
}
\arguments{
\item{mdr}{MDRs in claims data. \code{mdr} and \code{cdr} will be reshuffled and 
reordered internally.}

\item{cdr}{Claim damage ratios in claims data.}

\item{windowSize}{A positive integer as the sliding window size.}

\item{slidingSpeed}{A positive integer as the sliding speed.}

\item{sampleSize}{Sample size for each member in the ensemble.}

\item{NsampleSets}{Ensemble size. Default to 100.}

\item{targetMDRs}{Prescribed MDRs. Default to the 18999 MDRs in coverage
A, B, C PMF tables: 0.00001, 0.00002, ..., 0.09999, 0.1000, 0.1001, 
0.1002 ..., 0.9999.}

\item{interpolationMethod}{Interpolation method, either \code{"linear"} or 
\code{"hyman"}. Default to \code{"linear"}, which invokes 
\code{\link[stats]{approxfun}(method = "linear")}.
\code{"hyman"} invokes \code{\link[stats]{splinefun}(method = "hyman")}. 
The argument controls how we interpolate the longest monotonic subsequence
of \eqn{P_0} (or \eqn{\max}). The interpolation function is then used to
estimate the \eqn{P_0} (or \eqn{\max}) at any MDR.}

\item{linearIntpoThenCpp}{A boolean. If \code{interpolationMethod} is 
\code{"linear"} and \code{linearIntpoThenCpp} is true, use the speed 
optimized version of routine for modeling \eqn{P_0}.}

\item{randomSeed}{Random seed. Default to \code{42}.}

\item{maxCore}{Maximum number of CPU cores to use. 
Default to \code{parallel::detectCores()}.}

\item{tempDir}{A directory for saving computing progress. Default to
\code{"../tempFiles/CharlieTempMP/C"}. Will be created if nonexistent.}

\item{verbose}{\code{TRUE} prints computing progress. Default \code{TRUE}.}
}
\value{
A list of the \code{NsampleSets} \eqn{P_0} models.
}
\description{
Model \eqn{P_0} from data via the ensemble approach. The ensemble size can
be set to 1.
}
\details{
More details can be found in the slide documentation 
\href{../doc/slides.pdf}{\code{vignette('slides', package = 'NGFMfitDistr')}}.
}
\note{
If the ensemble approach is not to be used, set \code{sampleSize} to
\code{length(mdr)}, and set \code{NsampleSets} to \code{1}.
}
\examples{
library(NGFMfitDistr)
data(NewZealandCvgA, package = "NGFMfitDistr")
str(NewZealandCvgA)


mdrs = c(1:10000, seq(1e4L + 10L, 1e5L - 10L, by = 10L)) / 1e5
dat = data.frame(MDR = NewZealandCvgA$MDR, CDR = NewZealandCvgA$CDR)
dat = dat[sample(nrow(dat)), , drop = FALSE]
dat = dat[order(dat$MDR), , drop = FALSE]


p0ens = ensembleP0(
  # ============================================================================
  # Users need to ensure data rows have been ordered by MDR and CDR.
  mdr = NewZealandCvgA$MDR,
  cdr = NewZealandCvgA$CDR,
  # ============================================================================
  windowSize = round(nrow(NewZealandCvgA) * 0.01),
  slidingSpeed = round(nrow(NewZealandCvgA) * 1e-4),
  sampleSize = round(nrow(NewZealandCvgA) * (1 - 1 / exp(1))),
  NsampleSets = 100L,
  targetMDRs = mdrs,
  interpolationMethod = "hyman",
  randomSeed = 42L,
  maxCore = parallel::detectCores(),
  tempDir = "../tempFiles/CharlieTempMP/C"
)


# Plot the ensemble average against MDR.
plot(x = mdrs, y = rowMeans(as.data.frame(p0ens)), type = "l", 
     xlab = "MDR", ylab = expression(P[0]), bty = "L", las = 1)
}
