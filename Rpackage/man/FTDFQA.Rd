% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R
\name{FTDFQA}
\alias{FTDFQA}
\title{Inflated Transformed Beta Discretization}
\usage{
FTDFQA(
  TrBtable,
  supportSizes,
  regridMethod = "lr",
  RIBlib = "Numerical Recipes",
  outputProbsInRows = FALSE,
  fineDiscretizationSize = 2000L,
  maxCore = 1000L,
  verbose = TRUE,
  downScaleSupport = FALSE
)
}
\arguments{
\item{TrBtable}{A numeric matrix of 7 rows. Each column is a vector of
\code{(MDR, max, }\eqn{P_0}\code{, a, b, c, d)}.}

\item{supportSizes}{An integer vector, e.g. \code{c(64, 42)}.}

\item{regridMethod}{Regrid method: \code{"lr"} (linear regrid) or 
\code{"lmm"} (local moment matching) or \code{"r4"} (four-point regrid).
Default to \code{"lr"}.}

\item{RIBlib}{A string to specify which library should be used to 
compute the \href{https://en.wikipedia.org/wiki/Beta_function#Incomplete_beta_function}{Regularized Incomplete Beta function}
that TrB CDF depends on. 
\itemize{
\item{\code{"Numerical Recipes"}}{ implements the textbook algorithm in
\href{https://e-maxx.ru/bookz/files/numerical_recipes.pdf}{Chapter 6.4, Numerical Recipes}.
\href{https://live.boost.org/doc/libs/1_54_0/libs/math/doc/html/math_toolkit/sf_beta/ibeta_function.html}{Boost}, 
which claims the textbook algorithm's series expansion converges less 
rapidly than its own approach, actually runs considerably slower because 
it pursues much higher numeric precision.
Such extreme precision turns out largely unncessary in our setting. 
\code{"Numerical Recipes"} is the default and 
the recommended choice.}

\item{\code{"R::pbeta"}}{ calls R's Beta CDF. It is slower than \code{"Numerical Recipes"}
but faster than \code{"Boost"}. In numerically pathological regions, 
\code{"R::pbeta"} is more precise than \code{"Numerical Recipes"} 
but less so than \code{"Boost"}.}

\item{\code{"Boost"}}{ calls \href{https://live.boost.org/doc/libs/1_54_0/libs/math/doc/html/math_toolkit/sf_beta/ibeta_function.html}{boost::math::ibeta}.
It is the slowest but yields much higher precision especially 
in numerically pathological regions.}
}}

\item{outputProbsInRows}{A boolean. \code{TRUE} will produce a PMF 
table (matrix) where every row is a vector of (\code{MDR, max}, \eqn{P_0}, 
\code{P1, ..., Pmax}). \code{FALSE} will store it in a column. 
Default to \code{FALSE}.}

\item{fineDiscretizationSize}{An integer. Support size for raw 
discretization before tunning. Default to 2000.}

\item{maxCore}{The number of CPU cores for use. Default to 1000. A number
greater than the actual number of logical processors will be capped.
The bidirectional sequential fitting, which is the most likely to be used, 
is single-threaded if the initialization \code{abc} is singular --- when
\eqn{K=1}.}

\item{verbose}{A boolean. \code{TRUE} prints QA checking messages.}

\item{downScaleSupport}{A boolean. When the raw discretization's mean is
less than MDR, \code{TRUE} will downscale the support to match the MDR, 
while \code{FALSE} will increase \eqn{P_0} and downscale the main part 
probabilities to match the MDR. Default to \code{FALSE}, which is the 
better choice from experiments.}
}
\value{
A list of two named objects:
\itemize{
\item\code{distTable}: A list of final PMF tables corresponding to 
\code{supportSizes}. 

Names of the tables in \code{distTable} are \code{p} succeeded by 
the support sizes. For example, 
if \code{supportSizes = c(42L, 64L)}, then the names would be
\code{'p42'} and \code{'p64'}.

If \code{outputProbsInRows = FALSE}, every column 
of \code{distTable$p42} or \code{distTable$p64} would be 
\code{MDR, max, P0, P1, ..., Pmax}. Otherwise the tables are transposed.

\item\code{distTableBeforeTune}: A list of PMF tables before tuning for
monotonicity requirements. These are returned for diagnostics.
}
}
\description{
\strong{F}ine-tuned \strong{D}iscretization for \strong{F}ulfilling \strong{QA}
requirements, i.e. FTDFQA. The function produces a PMF table from an 
inflated TrB parameter table.
}
\details{
More details can be found in the slide documentation 
\href{../doc/slides.pdf}{\code{vignette('slides', package = 'NGFMfitDistr')}}.
}
\examples{
# ==============================================================================
# `tmpParam` comes with the package. It is a matrix of 4 rows. Each column
# contains (a, b, c, lm1). `lm1` is the limited mean.
# ==============================================================================
data(tmpParam, package = "NGFMfitDistr")


# ==============================================================================
# `P0forTest` comes with the package.
# ==============================================================================
data(P0forTest, package = "NGFMfitDistr")
P0 = P0forTest


# ==============================================================================
# Solve the scale parameter d.
# ==============================================================================
d = solve_d(tmpParam, eps = 1e-8, maxit = 100)
abcd = rbind(tmpParam[1:3, , drop = FALSE], d)
dimnames(abcd) = NULL


# ==============================================================================
# Let tentative max be equal to the 99-th percentile --- if this percentile
# is below 1.
# ==============================================================================
tailProbThreshold = 1 - 0.99


# ==============================================================================
# We do not want the max to be too low.
# ==============================================================================
maxLowerBound = 0.05


mdrs = c(1:1e4L, seq(1e4L + 10L, 1e5L - 10L, by = 10L)) / 1e5


# ==============================================================================
# Compute the maxes.
# ==============================================================================
maxes = pmin(1, actuar_qtrbeta(1 - tailProbThreshold / (1 - P0), abcd))
maxes[!is.finite(maxes)] = 0 # In case of errors.
maxes = pmax(maxLowerBound, maxes)
ind = longestNonDecreasingSubseq(maxes)
maxFun = splinefun(x = mdrs[ind], y = maxes[ind], method = "hyman")
maxes = maxFun(mdrs)


# ==============================================================================
# Create TrB parameter table.
# ==============================================================================
TrBtable = rbind(mdrs, maxes, P0, abcd)


# ==============================================================================
# Discretization
# ==============================================================================
pmftablelist = FTDFQA(
  TrBtable, 
  supportSize = c(42L, 64L), 
  regridMethod = "lr",
  RIBlib = "Numerical Recipes",
  outputProbsInRows = TRUE,
  fineDiscretizationSize = 2000,
  maxCore = 1000, 
  verbose = TRUE, 
  downScaleSupport = FALSE)





}
