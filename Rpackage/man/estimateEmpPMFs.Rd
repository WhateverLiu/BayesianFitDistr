% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/estimateEmpPMFs.R
\name{estimateEmpPMFs}
\alias{estimateEmpPMFs}
\title{Compute empirical PMFs}
\usage{
estimateEmpPMFs(
  mdr,
  cdr,
  windows,
  P0,
  targetMDRs = c(1:10000L, seq(10000L + 10L, 100000L - 10L, by = 10L))/1e+05,
  regridMethod = "lr",
  nonDegenerateOldDistrs = NULL,
  sampleWeightOnOldDistrs = 0.5,
  empDistrSupportSize = 64L,
  maxCore = parallel::detectCores()
)
}
\arguments{
\item{mdr}{MDRs in claims data. \code{mdr} and \code{cdr} will be reshuffled and 
reordered internally.}

\item{cdr}{Claim damage ratios in claims data.}

\item{windows}{A list of size-2 integer vectors. Most likely a result from
from function \code{\link{computeWindows}}.}

\item{P0}{A numeric vector. Modeled P0s corresponding to \code{targetMDRs}.}

\item{targetMDRs}{Prescribed MDRs. Default to the 18999 MDRs in coverage
A, B, C PMF tables: 0.00001, 0.00002, ..., 0.09999, 0.1000, 0.1001, 
0.1002 ..., 0.9999.}

\item{regridMethod}{Regrid method. \code{"lr"} implies linear regrid.
\code{"lmm"} implies local moment matching. \code{"r4"} implies four-point 
regrid. Default to \code{"lr"}.}

\item{nonDegenerateOldDistrs}{A list of old PMFs for Bayesian update. The list
should have the same length as \code{targetMDRs}. Each PMF is a list or 
data frame of size 2: the 1st vector is the support, and the 2nd vector 
is the probabilities. Default to \code{NULL}, which implies no Bayesian update.}

\item{sampleWeightOnOldDistrs}{Sampling weight in \code{[0, 1]} on the old 
distributions. Ignored if \code{nonDegenerateOldDistrs} is \code{NULL}.}

\item{empDistrSupportSize}{Support size in each of the result PMFs.}

\item{maxCore}{The number of CPU cores to be used.}
}
\value{
A list of two objects:
\itemize{
\item{\code{biased}}{  List of empirical PMFs.}
\item{\code{biasedCorrected}}{  List of empirical PMFs whose supports have been
scaled such that their means match the prescribed MDRs. This list of PMFs
is not recommended to be fitted by TrB unless the biases are extreme.}
}
}
\description{
Estimate the empirical PMFs associated to the MDRs of interest.
}
\details{
More details can be found in 
\code{vignette("slides", package = "NGFMfitDistr")}.
}
\examples{
library(NGFMfitDistr)
data(NewZealandCvgA, package = "NGFMfitDistr"); str(NewZealandCvgA)


# ==============================================================================
# A P0 model just for example.
# ==============================================================================
data(P0forTest, package = "NGFMfitDistr")


# ==============================================================================
# Make sliding windows.
# ==============================================================================
windows = computeWindows(
  xlen = nrow(NewZealandCvgA), 
  windowSize = round(nrow(NewZealandCvgA) * 0.01),
  start = 1L,
  speed = round(nrow(NewZealandCvgA) * 1e-4),
  returnList = TRUE
  )


# ==============================================================================
# Because NewZealandCvgA has been ordered by MDR and CDR, we need to reshuffle
# the rows of NewZealandCvgA and resort it by MDR only. This is because there
# are many different CDRs associated to the same MDR in this dataset.
# ==============================================================================
set.seed(123)
NewZealandCvgA = NewZealandCvgA[sample(nrow(NewZealandCvgA)), , drop = FALSE]
NewZealandCvgA = NewZealandCvgA[order(NewZealandCvgA$MDR), , drop = FALSE]
  

rst = estimateEmpPMFs(
    mdr = NewZealandCvgA$MDR, 
    cdr = NewZealandCvgA$CDR, 
    windows = windows, 
    P0 = P0forTest,
    targetMDRs = c(1:1e4L, seq(1e4L + 10L, 1e5L - 10L, by = 10L)) / 1e5,
    regridMethod = "lmm",
    nonDegenerateOldDistrs = NULL,
    sampleWeightOnOldDistrs = 0.5,
    empDistrSupportSize = 64L,
    maxCore = parallel::detectCores())


}
