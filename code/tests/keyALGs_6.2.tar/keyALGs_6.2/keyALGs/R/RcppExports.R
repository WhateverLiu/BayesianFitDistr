# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#'
#' Linear regriding
#'
#' Linear regrid a PMF
#'
#' @param X A 2-column data frame \code{(support, probability)} as the PMF.
#' Elements in \code{support} must be sorted and have no duplicates.
#' \code{probability} should be nonnegative.
#'
#' @param ngd A sorted numeric vector as the new grid: \code{ngd[1] <= support[1]}
#' AND \code{ngd[length(ngd)] >= support[length(support)]}.
#'
#' @details See \href{https://www.mdpi.com/2227-9091/7/2/54/htm}{Direct and
#' Hierarchical Models for Aggregating Spatially Dependent Catastrophe Risks}.
#'
#' @return A 2-column data frame as the regrided PMF. Column names are
#' \code{"val"} and \code{"P"}.
#'
#' @example inst/examples/rglr.R
#'
rglr <- function(X, ngd) {
    .Call('_keyALGs_rglr', PACKAGE = 'keyALGs', X, ngd)
}

#'
#' Brute-force convolution
#'
#' Brute-force convolve two PMFs where each PMF's support can be fully irregular.
#' 
#' @inheritParams rglr
#' 
#' @param Y  Same as \code{X}.
#' 
#' @param eps  Numeric threshold to define equality between double-precision 
#' floats: if \code{|a - b| < eps}, then \code{a} and \code{b} are treated as 
#' equal. Default \code{1e-10}. 
#' 
#' @inherit rglr return
#' 
#' @example inst/examples/convBt.R
#' 
convBt <- function(X, Y, eps = 1e-10) {
    .Call('_keyALGs_convBt', PACKAGE = 'keyALGs', X, Y, eps)
}

inverseRglr <- function(X, ngd, normalize = TRUE) {
    .Call('_keyALGs_inverseRglr', PACKAGE = 'keyALGs', X, ngd, normalize)
}

gm2dParallel <- function(Long, Lat, val, weight, miu1, miu2, var1, var2, covar, weightEPS, convergeEPS, maxit, showProgress, NofCore, convergeRelativeDiff = 1L, ellipseAxisRatioThreshold = 14.2) {
    .Call('_keyALGs_gm2dParallel', PACKAGE = 'keyALGs', Long, Lat, val, weight, miu1, miu2, var1, var2, covar, weightEPS, convergeEPS, maxit, showProgress, NofCore, convergeRelativeDiff, ellipseAxisRatioThreshold)
}

gm2d <- function(Long, Lat, val, weight, miu1, miu2, var1, var2, covar, weightEPS, convergeEPS, maxit, showProgress, useRelativeDiff, ellipseAxisRatioThreshold = 14.2) {
    .Call('_keyALGs_gm2d', PACKAGE = 'keyALGs', Long, Lat, val, weight, miu1, miu2, var1, var2, covar, weightEPS, convergeEPS, maxit, showProgress, useRelativeDiff, ellipseAxisRatioThreshold)
}

gm2dComponentWise <- function(Long, Lat, val, weight, miu1, miu2, var1, var2, covar, weightEPS, convergeEPS, maxit, showProgress, useRelativeDiff, ellipseAxisRatioThreshold = 14.2) {
    .Call('_keyALGs_gm2dComponentWise', PACKAGE = 'keyALGs', Long, Lat, val, weight, miu1, miu2, var1, var2, covar, weightEPS, convergeEPS, maxit, showProgress, useRelativeDiff, ellipseAxisRatioThreshold)
}

GMKtotalVarCpp <- function(location, GMkernel, locationVar, corM, weightEPS = 1e-12, outputCorM = 0L, useMahalanobisD = 0L) {
    .Call('_keyALGs_GMKtotalVarCpp', PACKAGE = 'keyALGs', location, GMkernel, locationVar, corM, weightEPS, outputCorM, useMahalanobisD)
}

GMKtotalVarCppParallel <- function(location, GMkernel, locationVar, corM, indexV, indexVector, weightEPS, outputCorM, absorbWeightInLocalCovar, useMahalanobisDforWeight) {
    .Call('_keyALGs_GMKtotalVarCppParallel', PACKAGE = 'keyALGs', location, GMkernel, locationVar, corM, indexV, indexVector, weightEPS, outputCorM, absorbWeightInLocalCovar, useMahalanobisDforWeight)
}

vecD <- function(x, y, ms = "Cheb") {
    .Call('_keyALGs_vecD', PACKAGE = 'keyALGs', x, y, ms)
}

testSampleSort <- function(x, eleByteSize = 4L) {
    invisible(.Call('_keyALGs_testSampleSort', PACKAGE = 'keyALGs', x, eleByteSize))
}

testSampleSortOnKeys <- function(key) {
    invisible(.Call('_keyALGs_testSampleSortOnKeys', PACKAGE = 'keyALGs', key))
}

testLowerBounds <- function(x, y, eleByte = 4L) {
    .Call('_keyALGs_testLowerBounds', PACKAGE = 'keyALGs', x, y, eleByte)
}

testLowerBoundsOnKeys <- function(key, splitterInd) {
    invisible(.Call('_keyALGs_testLowerBoundsOnKeys', PACKAGE = 'keyALGs', key, splitterInd))
}

lmm2ndM <- function(dist, newSupport) {
    .Call('_keyALGs_lmm2ndM', PACKAGE = 'keyALGs', dist, newSupport)
}

rglr3split <- function(X, ngd) {
    .Call('_keyALGs_rglr3split', PACKAGE = 'keyALGs', X, ngd)
}

#'
#' Four-point regriding
#' 
#' Regrid a PMF using four-point regriding. The algorithm usually but not always 
#' preserves the PMF's second moment.
#' 
#' @inherit rglr
#' 
#' @example inst/examples/rglr4split.R
rglr4split <- function(X, ngd) {
    .Call('_keyALGs_rglr4split', PACKAGE = 'keyALGs', X, ngd)
}

rglr4splitGuassianKernal <- function(X, ngd) {
    .Call('_keyALGs_rglr4splitGuassianKernal', PACKAGE = 'keyALGs', X, ngd)
}

truncateDistSingleTest <- function(X, headTrunc = 0, tailTrunc = 0) {
    .Call('_keyALGs_truncateDistSingleTest', PACKAGE = 'keyALGs', X, headTrunc, tailTrunc)
}

truncateDistTest <- function(X, headTrunc = 0, tailTrunc = 0) {
    .Call('_keyALGs_truncateDistTest', PACKAGE = 'keyALGs', X, headTrunc, tailTrunc)
}

convSplitAtom4productsAtomUntouched <- function(X, Y, regridMethod = "lr", N = 256L, forDeltaCompare = 256L, leftTrunc = 0, rightTrunc = 0, useFFT = 0L) {
    .Call('_keyALGs_convSplitAtom4productsAtomUntouched', PACKAGE = 'keyALGs', X, Y, regridMethod, N, forDeltaCompare, leftTrunc, rightTrunc, useFFT)
}

convSplitAtom9productsAtomUntouched <- function(X, Y, regridMethod = "lr", N = 256L, forDeltaCompare = 256L, leftTrunc = 0, rightTrunc = 0, useFFT = 0L) {
    .Call('_keyALGs_convSplitAtom9productsAtomUntouched', PACKAGE = 'keyALGs', X, Y, regridMethod, N, forDeltaCompare, leftTrunc, rightTrunc, useFFT)
}

convSplitAtom4products <- function(X, Y, regridMethod = "lr", N = 256L, forDeltaCompare = 256L, leftTrunc = 0, rightTrunc = 0, useFFT = 0L) {
    .Call('_keyALGs_convSplitAtom4products', PACKAGE = 'keyALGs', X, Y, regridMethod, N, forDeltaCompare, leftTrunc, rightTrunc, useFFT)
}

convSplitAtom9products <- function(X, Y, regridMethod = "lr", N = 256L, forDeltaCompare = 256L, leftTrunc = 0, rightTrunc = 0, useFFT = 0L) {
    .Call('_keyALGs_convSplitAtom9products', PACKAGE = 'keyALGs', X, Y, regridMethod, N, forDeltaCompare, leftTrunc, rightTrunc, useFFT)
}

#'
#' Split-atom Four-products Convolution
#'
#' Convolve two PMFs using four-products convolution. Each PMF's support should 
#' be regular (have equal step sizes) except for the last step. \code{"Irregular"} 
#' refers to the fact that the size of the last step can be less.
#' 
#' @inheritParams rglr
#' 
#' @param Y Same as \code{X}.
#'
#' @param regridMethod  Regriding method in the routine:
#' 
#' \code{"lr"}: linear regrid. Default.
#' 
#' \code{"r4"}: four-point regrid.
#' 
#' \code{"r3"}: three-point regrid. For author's personal use.
#' 
#' \code{"r4g"}: four-point regrid with Gaussian kernel. For author's personal use.
#' 
#' Before convolution, one or both the PMFs need to be regrided such that they have
#' equal step size (main delta) except for the last steps (minor delta),
#' which can be smaller. See \code{forDeltaCompare} for how to determine the 
#' delta of the convolution PMF.
#' 
#' @param N  Maximum points allowed on the result PMF's support. Default 256.
#' 
#' 
#' @param forDeltaCompare For computing the main delta on the convolution grid.
#' Let \code{x} and \code{y} be the supports of \code{X} and \code{Y}, 
#' and \code{dx} and \code{dy} be the main deltas. The function first computes
#' the convolution grid's width \code{w = max(x) + max(y) - (min(x) + min(y))},
#' and then let \code{dc = max( dx, dy, w / forDeltaCompare )} be the main delta
#' on the convolution grid. The minor delta is thus \code{w \% dc}
#' In software release \code{forDeltaCompare == N}. 
#' Do not set \code{forDeltaCompare > N}.
#' 
#' 
#' @param leftTrunc  Nonnegative left tail truncation threshold. If nonzero, 
#' the left tail with probabilities \code{< leftTrunc} are truncated. Default 1e-10.
#' 
#' @param rightTrunc  Nonnegative right tail truncation threshold. If nonzero, 
#' the right tail with probabilities \code{< rightTrunc} are truncated. Default 1e-10.
#' 
#' @param useFFT Use Fast Fourier Transform. Default FALSE.
#'
#' @inherit rglr details
#'
#' @return A 2-column data frame as the result PMF. The PMF's support is 
#' regular except for the last step size which could be less.
#' 
#' @example inst/examples/convSplitAtom4productsIrregular.R
#'
convSplitAtom4productsIrregular <- function(X, Y, regridMethod = "lr", N = 256L, forDeltaCompare = 256L, leftTrunc = 1e-10, rightTrunc = 1e-10, useFFT = FALSE) {
    .Call('_keyALGs_convSplitAtom4productsIrregular', PACKAGE = 'keyALGs', X, Y, regridMethod, N, forDeltaCompare, leftTrunc, rightTrunc, useFFT)
}

convSplitAtom9productsIrregular <- function(X, Y, regridMethod = "lr", N = 256L, forDeltaCompare = 256L, leftTrunc = 0, rightTrunc = 0, useFFT = 0L) {
    .Call('_keyALGs_convSplitAtom9productsIrregular', PACKAGE = 'keyALGs', X, Y, regridMethod, N, forDeltaCompare, leftTrunc, rightTrunc, useFFT)
}

#' 
#' Sequential convolution
#' 
#' Convolve a list of PMFs sequentially.
#' 
#' @param lisOfDists 
#'   A list of PMFs. 
#' 
#'   Each PMF is a 2-column data frame \code{(support, probability)}. 
#'   \code{support} should be regular (equal step sizes). \code{probability} 
#'   should be nonnegative. 
#' 
#'   A degenerate PMF must be a 1-row data frame. A degenerate PMF represented as 
#'   \code{data.frame(val = c(0, 1, 2), P = c(0, 0, 1))} instead of 
#'   \code{data.frame(val = 2, P = 1)} can lead to runtime error.
#' 
#' 
#' @param convMethod
#'   Convolution method:
#'   
#'   \code{"splitAtom4productsIrregular"}: use 
#'   \code{\link{convSplitAtom4productsIrregular}}, the routine in 
#'   software release. Default.
#' 
#'   \code{"convbt"}: use \code{\link{convBt}}, brute-force convolution.
#' 
#'   The following were implemented for personal use:
#' 
#'   \code{"splitAtom4products"}: use \code{\link{convSplitAtom4products}}.
#' 
#'   \code{"splitAtom9products"}: use \code{\link{convSplitAtom9products}}.
#' 
#'   \code{"splitAtom4productsAtomUntouched"}: 
#'     use \code{\link{convSplitAtom4productsAtomUntouched}}.
#' 
#'   \code{"splitAtom9productsAtomUntouched"}: 
#'     use \code{\link{convSplitAtom9productsAtomUntouched}}.
#' 
#'   \code{"splitAtom9productsIrregular"}: 
#'     use \code{\link{convSplitAtom9productsIrregular}}.
#' 
#'
#' @inheritParams convSplitAtom4productsIrregular
#' 
#' @inherit convSplitAtom4productsIrregular return
#' 
#' @details See convolution function, e.g., \code{\link{convSplitAtom4productsIrregular}}
#' and \href{https://www.mdpi.com/2227-9091/7/2/54/htm}{Direct and Hierarchical 
#' Models for Aggregating Spatially Dependent Catastrophe Risks}.
#' 
#' @example inst/examples/sequentialConvAll.R
sequentialConvAll <- function(lisOfDists, convMethod = "splitAtom4productsIrregular", headTrunc = 1e-10, tailTrunc = 1e-10, regridMethod = "lr", N = 256L, forDeltaCompare = 256L, useFFT = FALSE) {
    .Call('_keyALGs_sequentialConvAll', PACKAGE = 'keyALGs', lisOfDists, convMethod, headTrunc, tailTrunc, regridMethod, N, forDeltaCompare, useFFT)
}

#'
#' Sorted sequential convolution
#' 
#' Sort the list of distributions by distribution's support step size, and then 
#' call \code{\link{sequentialConvAll}}. This MAY mitigate variance inflation.
#' 
#' @inherit sequentialConvAll
#'
#' @example inst/examples/sortedSequentialConvAll.R
sortedSequentialConvAll <- function(lisOfDists, convMethod = "splitAtom4productsIrregular", headTrunc = 1e-10, tailTrunc = 1e-10, regridMethod = "lr", N = 256L, forDeltaCompare = 256L, useFFT = FALSE) {
    .Call('_keyALGs_sortedSequentialConvAll', PACKAGE = 'keyALGs', lisOfDists, convMethod, headTrunc, tailTrunc, regridMethod, N, forDeltaCompare, useFFT)
}

#'
#' Closest pair convolution
#' 
#' Recursively searches for pairs of PMFs that have the closest step sizes to 
#' convolve. This typically incurs the least variance inflation. It is later 
#' also referred to as \emph{recursive nearest neighbor order of convolution}.
#' 
#' @inherit sequentialConvAll
#' 
#' @example inst/examples/closestPairConvAll.R
#'
closestPairConvAll <- function(lisOfDists, convMethod = "splitAtom4productsIrregular", headTrunc = 1e-10, tailTrunc = 1e-10, regridMethod = "lr", N = 256L, forDeltaCompare = 256L, useFFT = 0L) {
    .Call('_keyALGs_closestPairConvAll', PACKAGE = 'keyALGs', lisOfDists, convMethod, headTrunc, tailTrunc, regridMethod, N, forDeltaCompare, useFFT)
}

partition3wayLRMconv <- function(lisOfDists, convMethod, single, headTrunc, tailTrunc, regridMethod = "lr", N = 256L, forDeltaCompare = 256L, useFFT = 0L) {
    .Call('_keyALGs_partition3wayLRMconv', PACKAGE = 'keyALGs', lisOfDists, convMethod, single, headTrunc, tailTrunc, regridMethod, N, forDeltaCompare, useFFT)
}

BLDMconv <- function(lisOfDists, convMethod, single, headTrunc, tailTrunc, regridMethod = "lr", N = 256L, forDeltaCompare = 256L, useFFT = 0L) {
    .Call('_keyALGs_BLDMconv', PACKAGE = 'keyALGs', lisOfDists, convMethod, single, headTrunc, tailTrunc, regridMethod, N, forDeltaCompare, useFFT)
}

forBiggestRangeDiff <- function(lisOfDists, convMethod, single, headTrunc, tailTrunc, regridMethod = "lr", N = 256L, forDeltaCompare = 256L, useFFT = 0L) {
    .Call('_keyALGs_forBiggestRangeDiff', PACKAGE = 'keyALGs', lisOfDists, convMethod, single, headTrunc, tailTrunc, regridMethod, N, forDeltaCompare, useFFT)
}

lowerBound <- function(x, v) {
    .Call('_keyALGs_lowerBound', PACKAGE = 'keyALGs', x, v)
}

#'
#' Comonotonization
#' 
#' Compute the sum of two distributions assuming maximum correlation.
#' 
#' @inheritParams convSplitAtom4productsIrregular
#' 
#' @param N  Support size of the result PMF. Default 64. If \code{<= 1}, 
#' the function comonotonizes \code{X} and \code{Y} and returns the 
#' result without regriding. Comonotonization does not need the two PMFs to 
#' have common step sizes. The regriding can prevent the result PMF from being
#' too long.
#'
#' @param rgMethod  Regriding method:
#' 
#'   \code{"lr"}: linear regrid. Default.
#' 
#'   \code{"r4"}: four-point regrid.
#' 
#'   \code{""}: do not regrid. Has the same effect as \code{N <= 1}.
#' 
#' @param isUsedInCounterComo TRUE if this procedure is used for
#' counter-comonotonization. Default FALSE.
#'
#' @inherit rglr return
#' 
#' @inherit convSplitAtom4productsIrregular details
#' 
#' @example inst/examples/como.R
#' 
como <- function(X, Y, N = 64L, rgMethod = "lr", isUsedInCounterComo = FALSE) {
    .Call('_keyALGs_como', PACKAGE = 'keyALGs', X, Y, N, rgMethod, isUsedInCounterComo)
}

comoJoint2D <- function(X, Y) {
    .Call('_keyALGs_comoJoint2D', PACKAGE = 'keyALGs', X, Y)
}

mixConv2dist <- function(dist1, dist2, corWanted, regridMethod = 'r', N = 256L, dist1var = -1, dist2var = -1, useFFT = 0L) {
    .Call('_keyALGs_mixConv2dist', PACKAGE = 'keyALGs', dist1, dist2, corWanted, regridMethod, N, dist1var, dist2var, useFFT)
}

mixConv2distGivenVar <- function(dist1, dist2, varWanted, regridMethod = 'r', N = 256L, dist1var = -1, dist2var = -1, useFFT = 0L) {
    .Call('_keyALGs_mixConv2distGivenVar', PACKAGE = 'keyALGs', dist1, dist2, varWanted, regridMethod, N, dist1var, dist2var, useFFT)
}

mixConvSample <- function(sampleListR, fullDistListR, gridIndex, corsR, regridMethod = 'r', headTrunc = 1e-100, tailTrunc = 1e-100, N = 256L, forDeltaCompare = 256L, single = 1L, maxCore = 8L, useFFT = 0L) {
    .Call('_keyALGs_mixConvSample', PACKAGE = 'keyALGs', sampleListR, fullDistListR, gridIndex, corsR, regridMethod, headTrunc, tailTrunc, N, forDeltaCompare, single, maxCore, useFFT)
}

covarMatSum <- function(sampleList, variances, cors, gridInd, maxCore = 8L) {
    .Call('_keyALGs_covarMatSum', PACKAGE = 'keyALGs', sampleList, variances, cors, gridInd, maxCore)
}

generateCorMultiplier <- function(var, gridIndR) {
    .Call('_keyALGs_generateCorMultiplier', PACKAGE = 'keyALGs', var, gridIndR)
}

#'
#' Comonotonize a list of distributions
#' 
#' Comonotonize a list of PMFs sequentially.
#' 
#' @inheritParams sequentialConvAll
#' 
#' @param regridMethod 
#' Regriding method:
#' 
#'   \code{"lr"}: linear regrid. Default.
#' 
#'   \code{"r4"}: four-point regrid.
#' 
#' @inheritParams convSplitAtom4productsIrregular
#' 
#' @details  See \code{\link{como}}.
#' 
#' @inherit rglr return
#' 
#' @example inst/examples/comoDistList.R
#'
comoDistList <- function(lisOfDists, regridMethod = "lr", N = 256L) {
    .Call('_keyALGs_comoDistList', PACKAGE = 'keyALGs', lisOfDists, regridMethod, N)
}

#'
#' Distribution mean
#' 
#' Compute the mean of a PMF.
#' 
#' @inheritParams rglr
#' 
#' @return Mean of the PMF
#'
Mean <- function(X) {
    .Call('_keyALGs_Mean', PACKAGE = 'keyALGs', X)
}

#'
#' Distribution variance
#' 
#' Compute the variance of a PMF.
#' 
#' @inheritParams rglr
#' 
#' @return Variance of the PMF
#'
Var <- function(X) {
    .Call('_keyALGs_Var', PACKAGE = 'keyALGs', X)
}

encode <- function(inputPath, filetype, outputTxtName) {
    invisible(.Call('_keyALGs_encode', PACKAGE = 'keyALGs', inputPath, filetype, outputTxtName))
}

decode <- function(inputTxtPath, outputNameNoFileType) {
    invisible(.Call('_keyALGs_decode', PACKAGE = 'keyALGs', inputTxtPath, outputNameNoFileType))
}

matmul <- function(X, Y, maxCore = 16L, bidir = FALSE) {
    .Call('_keyALGs_matmul', PACKAGE = 'keyALGs', X, Y, maxCore, bidir)
}

mapTo <- function(rv, cdf) {
    .Call('_keyALGs_mapTo', PACKAGE = 'keyALGs', rv, cdf)
}

LHS <- function(pdf, N) {
    .Call('_keyALGs_LHS', PACKAGE = 'keyALGs', pdf, N)
}

testG3dVal <- function(x, para) {
    .Call('_keyALGs_testG3dVal', PACKAGE = 'keyALGs', x, para)
}

testAddr <- function(x) {
    invisible(.Call('_keyALGs_testAddr', PACKAGE = 'keyALGs', x))
}

vecAssign <- function(orginalV, index, newValueV) {
    invisible(.Call('_keyALGs_vecAssign', PACKAGE = 'keyALGs', orginalV, index, newValueV))
}

cholDecomp <- function(A, maxCore = 15L, useFullPara = TRUE) {
    .Call('_keyALGs_cholDecomp', PACKAGE = 'keyALGs', A, maxCore, useFullPara)
}

armaSolve <- function(X, y, fastsolve = TRUE) {
    .Call('_keyALGs_armaSolve', PACKAGE = 'keyALGs', X, y, fastsolve)
}

guassSeidelSolveDense <- function(X, y, maxIter = 1e6L, convergenceEPS = 1e-6) {
    .Call('_keyALGs_guassSeidelSolveDense', PACKAGE = 'keyALGs', X, y, maxIter, convergenceEPS)
}

paraOLS <- function(y, X, maxCore = 7L, verboseInt = 8192L, useGaussSeidel = FALSE, maxIter = 1e6L, convergenceEPS = 1e-6) {
    .Call('_keyALGs_paraOLS', PACKAGE = 'keyALGs', y, X, maxCore, verboseInt, useGaussSeidel, maxIter, convergenceEPS)
}

fullMatToSparseCol <- function(Xmat) {
    .Call('_keyALGs_fullMatToSparseCol', PACKAGE = 'keyALGs', Xmat)
}

fullMatToSparseRow <- function(Xmat) {
    .Call('_keyALGs_fullMatToSparseRow', PACKAGE = 'keyALGs', Xmat)
}

fullMatToSparseRowArmaFormat <- function(Xmat) {
    .Call('_keyALGs_fullMatToSparseRowArmaFormat', PACKAGE = 'keyALGs', Xmat)
}

guassSeidelSolveSparseDenseInput <- function(X, y, maxIter = 1e6L, convergenceEPS = 1e-6) {
    .Call('_keyALGs_guassSeidelSolveSparseDenseInput', PACKAGE = 'keyALGs', X, y, maxIter, convergenceEPS)
}

guassSeidelSolveSparseSparseInput <- function(sparseX, y, maxIter = 1e6L, convergenceEPS = 1e-6) {
    .Call('_keyALGs_guassSeidelSolveSparseSparseInput', PACKAGE = 'keyALGs', sparseX, y, maxIter, convergenceEPS)
}

paraOLSsparse <- function(y, X, sparseMat = NULL, sparseNonZeroThreshold = 0.2, maxCore = 7L, verboseInt = 8192L, useGaussSeidel = TRUE, maxIter = 1e6L, convergenceEPS = 1e-6) {
    .Call('_keyALGs_paraOLSsparse', PACKAGE = 'keyALGs', y, X, sparseMat, sparseNonZeroThreshold, maxCore, verboseInt, useGaussSeidel, maxIter, convergenceEPS)
}

#'
#' Four-point regriding details
#' 
#' Regrid a PMF using four-point regriding. The algorithm usually but not always 
#' preserves the PMF's second moment. In addition to the regrided PMF, the function 
#' returns some process information.
#' 
#' @inherit rglr4split
#' 
#' @return A list of 3:
#' \itemize{
#'   \item{\code{$RTL}}{ TRUE if the algorithm retreated to linear regriding.}
#'   \item{\code{$Nredist}}{ An integer. The number of redistributions of negative 
#'   probabilities in Stage II.}
#'   \item{\code{$resultDistr}}{ A 2-column data frame 
#'   \code{(support, probability)} as the regrided PMF.}
#'  }
#' 
#' @example inst/examples/rglr4splitDetails.R
rglr4splitDetails <- function(X, ngd) {
    .Call('_keyALGs_rglr4splitDetails', PACKAGE = 'keyALGs', X, ngd)
}

rglr2Dcpp <- function(dist, ngx, ngy) {
    .Call('_keyALGs_rglr2Dcpp', PACKAGE = 'keyALGs', dist, ngx, ngy)
}

