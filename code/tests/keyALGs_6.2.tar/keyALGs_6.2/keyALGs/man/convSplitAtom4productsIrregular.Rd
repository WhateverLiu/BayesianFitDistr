% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R
\name{convSplitAtom4productsIrregular}
\alias{convSplitAtom4productsIrregular}
\title{Split-atom Four-products Convolution}
\usage{
convSplitAtom4productsIrregular(
  X,
  Y,
  regridMethod = "lr",
  N = 256L,
  forDeltaCompare = 256L,
  leftTrunc = 1e-10,
  rightTrunc = 1e-10,
  useFFT = FALSE
)
}
\arguments{
\item{X}{A 2-column data frame \code{(support, probability)} as the PMF.
Elements in \code{support} must be sorted and have no duplicates.
\code{probability} should be nonnegative.}

\item{Y}{Same as \code{X}.}

\item{regridMethod}{Regriding method in the routine:

\code{"lr"}: linear regrid. Default.

\code{"r4"}: four-point regrid.

\code{"r3"}: three-point regrid. For author's personal use.

\code{"r4g"}: four-point regrid with Gaussian kernel. For author's personal use.

Before convolution, one or both the PMFs need to be regrided such that they have
equal step size (main delta) except for the last steps (minor delta),
which can be smaller. See \code{forDeltaCompare} for how to determine the 
delta of the convolution PMF.}

\item{N}{Maximum points allowed on the result PMF's support. Default 256.}

\item{forDeltaCompare}{For computing the main delta on the convolution grid.
Let \code{x} and \code{y} be the supports of \code{X} and \code{Y}, 
and \code{dx} and \code{dy} be the main deltas. The function first computes
the convolution grid's width \code{w = max(x) + max(y) - (min(x) + min(y))},
and then let \code{dc = max( dx, dy, w / forDeltaCompare )} be the main delta
on the convolution grid. The minor delta is thus \code{w \% dc}
In software release \code{forDeltaCompare == N}. 
Do not set \code{forDeltaCompare > N}.}

\item{leftTrunc}{Nonnegative left tail truncation threshold. If nonzero, 
the left tail with probabilities \code{< leftTrunc} are truncated. Default 1e-10.}

\item{rightTrunc}{Nonnegative right tail truncation threshold. If nonzero, 
the right tail with probabilities \code{< rightTrunc} are truncated. Default 1e-10.}

\item{useFFT}{Use Fast Fourier Transform. Default FALSE.}
}
\value{
A 2-column data frame as the result PMF. The PMF's support is 
regular except for the last step size which could be less.
}
\description{
Convolve two PMFs using four-products convolution. Each PMF's support should 
be regular (have equal step sizes) except for the last step. \code{"Irregular"} 
refers to the fact that the size of the last step can be less.
}
\details{
See \href{https://www.mdpi.com/2227-9091/7/2/54/htm}{Direct and
Hierarchical Models for Aggregating Spatially Dependent Catastrophe Risks}.
}
\examples{
# X's support must be regular except for the last step which can be less.
X = data.frame(val = seq(runif(1), runif(1) + 1, len = 100), P = runif(100))
stepSize = X$val[2] - X$val[1]
X = rbind(X, c( X$val[nrow(X)] + stepSize * runif(1), runif(1) ) )
X$P = X$P / sum(X$P)


# Y's support must be regular except for the last step which can be less.
Y = data.frame(val = seq(runif(1), runif(1) + 1, len = 200), P = runif(200))
stepSize = Y$val[2] - Y$val[1]
Y = rbind(Y, c( Y$val[nrow(Y)] + stepSize * runif(1), runif(1) ) )
Y$P = Y$P / sum(Y$P)


XplusY = keyALGs::convSplitAtom4productsIrregular(
  X, Y, regridMethod = "r4", N = 256)


cat("Result PMF has only nonnegative probabilities = ",
    min(XplusY$P) >= 0, "\n",
    "Sum of result PMF's probabilities = ",
    sum(XplusY$P), "\n",
    "Theoretical mean of the result PMF = ",
    keyALGs::Mean(X) + keyALGs::Mean(Y), "\n",
    "Actual mean of the result PMF = ",
    keyALGs::Mean(XplusY), "\n",
    "Theoretical variance of the result PMF = ",
    keyALGs::Var(X) + keyALGs::Var(Y), "\n",
    "Actual variance of the result PMF = ",
    keyALGs::Var(XplusY), "\n", 
    "Unique step sizes on the result PMF's support = ",
    paste0(unique(diff(XplusY$val)), collapse = ", "), ". Here, ",
    "the unique step sizes could be more than two in the printout, ",
    "but it is due to numeric precision limit.\n",
    sep = "")


par(mfrow = c(1, 3))
ylim = c(0, max(max(X$P), max(Y$P), max(XplusY$P)))
plot(X, type = "h", bty = "L", ylim = ylim, xlab = "", ylab = "")
plot(Y, type = "h", bty = "L", ylim = ylim, xlab = "", ylab = "")
plot(XplusY, type = "h", bty = "L", xlab = "", ylab = "", ylim = ylim)
}
