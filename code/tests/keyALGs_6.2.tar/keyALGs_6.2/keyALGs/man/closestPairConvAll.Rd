% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R
\name{closestPairConvAll}
\alias{closestPairConvAll}
\title{Closest pair convolution}
\usage{
closestPairConvAll(
  lisOfDists,
  convMethod = "splitAtom4productsIrregular",
  headTrunc = 1e-10,
  tailTrunc = 1e-10,
  regridMethod = "lr",
  N = 256L,
  forDeltaCompare = 256L,
  useFFT = 0L
)
}
\arguments{
\item{lisOfDists}{A list of PMFs. 

  Each PMF is a 2-column data frame \code{(support, probability)}. 
  \code{support} should be regular (equal step sizes). \code{probability} 
  should be nonnegative. 

  A degenerate PMF must be a 1-row data frame. A degenerate PMF represented as 
  \code{data.frame(val = c(0, 1, 2), P = c(0, 0, 1))} instead of 
  \code{data.frame(val = 2, P = 1)} can lead to runtime error.}

\item{convMethod}{Convolution method:
  
  \code{"splitAtom4productsIrregular"}: use 
  \code{\link{convSplitAtom4productsIrregular}}, the routine in 
  software release. Default.

  \code{"convbt"}: use \code{\link{convBt}}, brute-force convolution.

  The following were implemented for personal use:

  \code{"splitAtom4products"}: use \code{\link{convSplitAtom4products}}.

  \code{"splitAtom9products"}: use \code{\link{convSplitAtom9products}}.

  \code{"splitAtom4productsAtomUntouched"}: 
    use \code{\link{convSplitAtom4productsAtomUntouched}}.

  \code{"splitAtom9productsAtomUntouched"}: 
    use \code{\link{convSplitAtom9productsAtomUntouched}}.

  \code{"splitAtom9productsIrregular"}: 
    use \code{\link{convSplitAtom9productsIrregular}}.}

\item{regridMethod}{Regriding method in the routine:

\code{"lr"}: linear regrid. Default.

\code{"r4"}: four-point regrid.

\code{"r3"}: three-point regrid. For author's personal use.

\code{"r4g"}: four-point regrid with Gaussian kernel. For author's personal use.

Before convolution, one or both the PMFs need to be regrided such that they have
equal step size (main delta) except for the last steps (minor delta),
which can be smaller. See \code{forDeltaCompare} for how to determine the 
delta of the convolution PMF.}

\item{N}{Maximum points allowed on the result PMF's support. Default 256.}

\item{forDeltaCompare}{For computing the main delta on the convolution grid.
Let \code{x} and \code{y} be the supports of \code{X} and \code{Y}, 
and \code{dx} and \code{dy} be the main deltas. The function first computes
the convolution grid's width \code{w = max(x) + max(y) - (min(x) + min(y))},
and then let \code{dc = max( dx, dy, w / forDeltaCompare )} be the main delta
on the convolution grid. The minor delta is thus \code{w \% dc}
In software release \code{forDeltaCompare == N}. 
Do not set \code{forDeltaCompare > N}.}

\item{useFFT}{Use Fast Fourier Transform. Default FALSE.}
}
\value{
A 2-column data frame as the result PMF. The PMF's support is 
regular except for the last step size which could be less.
}
\description{
Recursively searches for pairs of PMFs that have the closest step sizes to 
convolve. This typically incurs the least variance inflation. It is later 
also referred to as \emph{recursive nearest neighbor order of convolution}.
}
\details{
See convolution function, e.g., \code{\link{convSplitAtom4productsIrregular}}
and \href{https://www.mdpi.com/2227-9091/7/2/54/htm}{Direct and Hierarchical 
Models for Aggregating Spatially Dependent Catastrophe Risks}.
}
\examples{
# Generate a list of 100 PMFs.
distlist = lapply(1:100, function(i)
{
  supportSize = sample(200, 1)
  supportRange = sort(runif(2))
  support = seq(supportRange[1], supportRange[2], len = supportSize)
  X = data.frame(val = support, P = runif(supportSize))
  X$P = X$P / sum(X$P); X
})


seqAggDistr = keyALGs::sequentialConvAll(distlist)
sortedSeqAggDistr = keyALGs::sortedSequentialConvAll(distlist)
closestPairAggDistr = keyALGs::closestPairConvAll(distlist)


theoreticalVar = sum(unlist(lapply(distlist, function(x) keyALGs::Var(x))))
cat("Theoretical aggregate variance = ", theoreticalVar, "\n",
    "Sequential aggregate variance = ", keyALGs::Var(seqAggDistr), "\n",
    "Sorted sequential aggregate variance = ", 
    keyALGs::Var(sortedSeqAggDistr), "\n", 
    "Recursive nearest neighbor aggregate variance = ", 
    keyALGs::Var(closestPairAggDistr), "\n",
    "Sorted sequential accumulation MAY mitigate variance inflation.\n",
    "Recursive nearest neighbor USUALLY incurs the least variance inflation.",
    sep = "")
}
